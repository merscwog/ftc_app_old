include ':FtcRobotController'

settings.extensions.create('ftc', FtcSettings, settings)

File ftcConfig = new File(rootDir.parent, 'ftc-config.gradle')
if (ftcConfig.exists()) {
  apply from: ftcConfig
}

if (settings.includeDefaultTeamModule) {
  include ':TeamCode'
}

def validateConfigOptions(ConfigObject config) {
  def extraFields = config.keySet() - 'ftc'
  if (extraFields) {
    throw new GradleException("Invalid content: ${extraFields}")
  }

  def ftcContents = config.get('ftc')
  if (ftcContents) {
    def extraContent = ftcContents.keySet() - ['type', 'name', 'enabled']

    if (extraContent) {
      throw new GradleException("Invalid content: ${extraContent}")
    }
  }

  def moduleType = config.ftc.type
  if (moduleType && ! ['injected', 'source', 'external'].contains(moduleType)) {
    throw new GradleException("""\
Invalid module type: ${moduleType}
Valid values are: 'injected', 'source' and 'external'""".stripMargin())
  }
}

Boolean convertToBoolean(thing) {
  Boolean result = true

  if (thing instanceof Boolean) {
    result = thing // Take boolean value in the raw
  }
  else if (thing instanceof String) {
    result = thing.toBoolean()
  }
  else if ((thing instanceof Map) && (thing.isEmpty())) {
    result = true // This is special config option case
  }
  else if (thing) {
    result = thing as Boolean
  }

  result
}

import static groovy.io.FileType.FILES
import static groovy.io.FileType.DIRECTORIES

File parentDir = rootDir.parentFile

if (settings.autoSearchByModuleFiles) {
  def moduleFilePattern = ~/ftc-module.gradle/

  parentDir.traverse(type      : FILES,
		     nameFilter: moduleFilePattern,
		     maxDepth  : 2) {
    File moduleFile ->
      logger.info "Parsing moduleFile: ${moduleFile}"

      ConfigSlurper slurper = new ConfigSlurper()
      ConfigObject config = slurper.parse(moduleFile.text)

      validateConfigOptions(config)

      if (! convertToBoolean(config.ftc.enabled)) {
	return
      }

      // NOTE: This is default type when not specified
      String type = config.ftc.type ?: 'external'

      if (type == 'source') {
	ftc.addExternalSourceSet(moduleFile.parentFile.canonicalPath)
	logger.info 'Adding external sourceSet from moduleFile'
      }
      else {
	File moduleDir = moduleFile.parentFile
	String moduleName = config.ftc.name ?: moduleDir.name

	if (type == 'external') {
	  ftc.addExternalModule(moduleName, moduleDir.canonicalPath)
	  logger.info "Adding external module '${moduleName}' from moduleFile"
	}
	else if (type == 'injected') {
	  ftc.addInjectedModule(moduleName, moduleDir.canonicalPath)
	  logger.info "Adding injected module '${moduleName} from moduleFile"
	}
      }
  }
}

if (settings.autoSearchForTeamModules || settings.autoSearchForTeamCode) {
  String pattern = settings.dirNameSearchPattern

  parentDir.eachFileMatch(DIRECTORIES, ~pattern) { File teamDir ->
    if (settings.autoSearchForTeamModules &&
	new File(teamDir, 'build.gradle').exists()) {

      ftc.addExternalModule(teamDir.name, teamDir.canonicalPath)
      logger.info "Adding module ${teamDir.name}"
    }
    else if ((settings.includeDefaultTeamModule &&
	      settings.autoSearchForTeamCode)) {

      ftc.addExternalSourceSet(teamDir)
      logger.info "Adding external sourceSet dir: ${sourcesRoot.canonicalPath}"
    }
    else {
      logger.info "Skipping external directory: ${teamDir.path}"
    }
  }
}

settings.externalModulePaths.each { String projName, File projPath ->
  include projName
  project(projName).projectDir = projPath
}

class FtcSettings {
  final Settings settings

  FtcSettings(final Settings settings) {
    this.settings = settings
    this.settings.ext.includeDefaultTeamModule = true
    this.settings.ext.autoSearchForTeamModules = false
    this.settings.ext.autoSearchForTeamCode = false
    this.settings.ext.autoSearchByModuleFiles = true
    this.settings.ext.dirNameSearchPattern = /[Tt]eam([0-9])+/
    this.settings.ext.externalModulePaths = [:]
    this.settings.gradle.ext.externalSourceFilePaths = []
    this.settings.gradle.ext.externalInjectedModules = []
  }

  void disableDefaultTeamModule() {
    settings.includeDefaultTeamModule = false
  }

  void enableSearchForExternalTeamModulesByPattern() {
    settings.autoSearchForTeamModules = true
  }

  void enableSearchForExternalSourceSetsByPattern() {
    settings.autoSearchForTeamCode = true
  }

  void disableSearchForExternalsByModulesFiles() {
    settings.autoSearchByModuleFiles = false
  }

  void setExternalDirectoryNameSearchPattern(String newPattern) {
    if (newPattern) {
      settings.dirNameSearchPattern = newPattern
    }
  }

  void addExternalModule(String name) {
    addExternalModule(name, name)
  }

  void addExternalModule(String name, String path) {
    if (! name?.startsWith(':')) {
      name = ":${name}"
    }

    def modulePath = new File(path)
    if (! modulePath.isAbsolute()) {
      modulePath = new File(settings.rootDir.parent, path)
    }

    settings.externalModulePaths[name] = modulePath
  }

  void addInjectedModule(String name) {
    addInjectedModule(name, name)
  }

  void addInjectedModule(String name, String path) {
    if (! name?.startsWith(':')) {
      name = ":${name}"
    }

    addExternalModule(name, path)
    settings.gradle.externalInjectedModules << name
  }

  void addExternalSourceSet(String path) {
    def sourceSetPath = new File(path)
    if (! sourceSetPath.isAbsolute()) {
      sourceSetPath = new File(settings.rootDir.parent, path)
    }

    File possibleSourcesRoot = new File(sourceSetPath, 'src/main/java')
    if (possibleSourcesRoot.exists()) {
      sourceSetPath = possibleSourcesRoot
    }

    settings.gradle.externalSourceFilePaths << sourceSetPath.canonicalPath
  }
}
